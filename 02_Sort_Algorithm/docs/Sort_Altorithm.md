# 정렬

주어진 데이터를 일정한 순서로 재배열하는 알고리즘으로 이러한 재배열을 통해 검색, 비교, 출력등의 작업을 효율적으로 수행할 수 있음

## 버블 정렬 (Bubble Sort)
### 개념

인접한 두 원소의 대소를 비교하여 순서가 잘못된 경우, 서로 교환하는 정렬 알고리즘

### 동작 방식

배열의 처음부터 끝까지 반복하여 인접한 두 원소의 대소를 비교해 정렬을 수행함

### 특징

* 구현이 간단하고, 코드 이해가 쉬웁
* 소규모 데이터 정렬에 간단하게 사용하기 용이

### 장/단점

* 장점
	* 추가적인 메모리 사용 X
* 단점
	* 다른 정렬 알고리즘에 비해 비효율적

### 복잡도

* 시간 복잡도: O(n^2)
* 공간 복잡도: O(1)

### 활용처

* 데이터가 이미 거의 정렬되어 있는 경우
* 정렬할 데이터의 크기가 작을 때 


## 삽입 정렬 (Insert Sort)
### 개념

배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬하는 알고리즘

### 동작 방식

두번째 Index부터 시작해 이전 index 원소들과 비교하여 적절한 위치에 삽입하면서 정렬 

### 특징

크기가 적은 데이터나, 대부분의 데이터가 이미 정렬된 경우 효과적

### 장/단점

* 장점
	* 추가적인 메모리 사용 X
* 단점
	* 데이터 양이 많거나, 정렬된 상태가 아닐 떄 효율성이 떨어짐

### 복잡도

* 시간 복잡도: O(n^2) / O(n)
* 공간 복잡도: O(n)

### 활용처

* 작은 데이터 세트를 정렬할 때 사용
* 다른 정렬 알고리즘의 전처리 단계로 활용


## 선택 정렬 (Select Sort)
### 개념

배열에서 최소값(또는 최대값)을 선택하여 정렬하는 알고리즘

### 동작 방식

아래 프로세스 반복 (n: {1 ~ n})
* n번째로 작은 데이터를 찾아 n번째 위치와 교환

### 특징

비교 횟수가 고정되어 있어, 어떤 데이터가 어떤 순서로 정렬되어 있던 비교횟수가 동일함

### 장/단점

* 장점
	* 추가적인 메모리 사용 X
* 단점
	* 불안정 정렬이며, 같은 값의 순서 보장 X

### 복잡도

* 시간 복잡도: O(n^2)
* 공간 복잡도: O(1)

### 활용처

* 데이터 셋의 크기가 작은 상황에서 활용

## 퀵 정렬 (Quick Sort)
### 개념

분할 정복 알고리즘을 기반으로 정렬하는 알고리즘으로, 기준점(pivot)을 기준으로 작은값은 왼쪽, 큰값은 오른쪽에 위치시키며 정렬하는 알고리즘

### 동작 방식

pivot을 선택하고, pivot을 기준으로 작은 것은 왼쪽, 큰 것은 오른쪽으로 위치시키며 정렬 수행

### 특징

평균적으로 매우 빠른 속도를 가지며, 분할 과정에서 추가적인 메모리가 필요하지 않음

### 장/단점

* 장점
	* 매우 효율적으로 정렬을 수행함
* 단점
	* 선택된 pivot에 따라 성능이 불규칙함

### 복잡도

* 시간 복잡도: O(nlogn) ~ O(n^2)
* 공간 복잡도: O(logn)

### 활용처

* 대부분의 상황에서 효율적으로 사용 가능
* 대용량 데이터 정렬

## 병합 정렬 (Merge Sort)
### 개념

분할 정복 알고리즘을 사용하여 정렬하는 방식으로, 배열을 반으로 나누고 각 부분을 정렬한 후 병합하는 방식으로 정렬하는 알고리즘

### 동작 방식

배열을 반으로 나누어 정렬된 부분 배열을 만든 후, 병합하여 전체 배열 정렬

### 특징

안정적인 정렬 방식이며, 재귀적인 방식으로 구현 가능

### 장/단점

* 장점
	* 평균적으로 매우 빠른 속도를 가짐
* 단점
	* 추가적인 메모리 필요

### 복잡도

* 시간 복잡도: O(nlogn)
* 공간 복잡도: O(n)

### 활용처

* 대용량 데이터 정렬


## 힙 정렬 (Heap Sort)
### 개념

힙(Heap) 자료구조를 이용하여 정렬하는 방식으로, 힙을 구성하고 최대 힙 또느 최소 힙을 유지하면서 졍렬을 수행하는 알고리즘

### 동작 방식

초기에 배열을 힙으로 구성한 후, 최상단 노드를 삭제하며 정렬 수행

### 특징

완전 이진 트리 구조를 사용하여 효율적으로 수현하며 추가적인 메모리를 사용하지 않음

최대/최소 힙
* 최대 힙: 부모노드가 항상 자식 노드보다 큼 -> 내림차순 정렬
* 최소 힙: 부모노드가 항상 자식 노드보다 작음 -> 오름차순 정렬

### 장/단점

* 장점
	* 매우 효율적으로 정렬 수행
* 단점
	* 안정적인 정렬 방식이 아님

### 복잡도

* 시간 복잡도: O(nlogn)
* 공간 복잡도: O(n)

### 활용처

* 대용량 데이터 정렬
* 우선순위 큐 구현

## 셸 정렬 (Shell Sort)
### 개념

삽입 정렬을 개선한 알고리즘으로, 배열을 일정한 간격으로 나누어 부분 리스트를 만들고, 각각의 부분 리스트를 삽입 정렬하는 알고리즘

### 동작 방식

일정한 간격(초기값: 전체 배열 길이의 반)을 설정하여 부분 리스트를 생성하고, 해당 부분 리스트를 삽입 정렬을 통해 정렬하며 간격을 줄여가면서 정렬

### 특징

간격에 따라 성능이 크게 달라질 수 있지만, 추가적인 메모리를 사용하지 않음

### 장/단점

* 장점
	* 평균적으로 삽입 정렬보다 빠름
* 단점
	* 최적의 간격을 찾기 어려운 경우도 존재함

### 복잡도

* 시간 복잡도: O(nlogn) ~ O(n^2)
* 공간 복잡도: O(1)

### 활용처

* 대용량 데이터 정렬 시, 삽입 정렬보다 빠른 알고리즘이 필요한 경우

## 기수 정렬 (Radix Sort)
### 개념

자릿수를 기준으로 정렬하는 알고리즘으로 LSD (가장 작은 자리수) 또는 MSD (가장 높은 수) 방식을 통해 정렬하는 알고리즘

### 동작 방식 (LSD)

가장 낮은 자리수부터 시작하여 정렬을 수행, 각 자리수별로 정렬
(일의 자리부터 시작해, 가장 높은 자리까지 정렬)

### 특징

안정적인 정렬 알고리즘이지만, 데이터 자리수가 큰 경우 공간 복잡도가 커질 수 있음

### 장/단점

* 장점
	* 안정적인 정렬 방식
* 단점
	* 일부 자리수가 없는 경우 사용 불가

### 복잡도

* 시간 복잡도: O(d*(n+k)) (d: 최대 자리수, k: 각 자리수 범위)
* 공간 복잡도: O(n + k): (k: 각 자리수 볌위)

### 활용처

* 특정 자리수를 기준으로 정렬 (ex. 정수, 문자열)


---

# 안정 정렬 vs 불안정 정렬

* 안정 정렬
  * 중복된 값이 입력 순서와 동일하게 정렬되는 알고리즘의 특성
  * ex) 삽입 정렬, 벙합 정렬, 버블 정렬

* 불안정 정렬
  * 중복된 값이 이력 순서와 동일하지 않게 정렬되는 알고리즘의 특성
  * ex) 쿽 정렬, 선택 정렬, 계수 정렬

